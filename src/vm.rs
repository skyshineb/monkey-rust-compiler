use crate::bytecode::{lookup_definition, Chunk, Opcode};
use crate::object::{Object, ObjectRef};
use crate::runtime_error::{RuntimeError, RuntimeErrorType};

/// Stack-based VM for executing compiled Monkey bytecode.
#[derive(Debug, Clone)]
pub struct Vm {
    chunk: Chunk,
    ip: usize,
    stack: Vec<ObjectRef>,
    globals: Vec<ObjectRef>,
    last_popped: Option<ObjectRef>,
}

impl Vm {
    pub fn new(chunk: Chunk) -> Self {
        Self {
            chunk,
            ip: 0,
            stack: Vec::new(),
            globals: Vec::new(),
            last_popped: None,
        }
    }

    pub fn run(&mut self) -> Result<ObjectRef, RuntimeError> {
        while self.ip < self.chunk.instructions.len() {
            let offset = self.ip;
            let opcode_byte = self.chunk.instructions[offset];
            let Some(opcode) = Opcode::from_byte(opcode_byte) else {
                return Err(self.runtime_error(
                    offset,
                    RuntimeErrorType::UnsupportedOperation,
                    format!("unknown opcode byte: {opcode_byte}"),
                ));
            };

            match opcode {
                Opcode::Constant => {
                    let idx = self.read_u16_operand(offset)?;
                    let Some(constant) = self.chunk.constants.get(idx).cloned() else {
                        return Err(self.runtime_error(
                            offset,
                            RuntimeErrorType::UnsupportedOperation,
                            format!("constant index out of bounds: {idx}"),
                        ));
                    };
                    self.push(constant, offset)?;
                    self.ip += 3;
                }
                Opcode::True => {
                    self.push(Object::Boolean(true).rc(), offset)?;
                    self.ip += 1;
                }
                Opcode::False => {
                    self.push(Object::Boolean(false).rc(), offset)?;
                    self.ip += 1;
                }
                Opcode::Null => {
                    self.push(Object::Null.rc(), offset)?;
                    self.ip += 1;
                }
                Opcode::Pop => {
                    self.pop(offset)?;
                    self.ip += 1;
                }
                Opcode::Add | Opcode::Sub | Opcode::Mul | Opcode::Div => {
                    self.exec_binary_arithmetic(opcode, offset)?;
                    self.ip += 1;
                }
                Opcode::Neg => {
                    let operand = self.pop(offset)?;
                    let result = match operand.as_ref() {
                        Object::Integer(v) => Object::Integer(-v).rc(),
                        Object::Null => Object::Null.rc(),
                        other => {
                            return Err(self.runtime_error(
                                offset,
                                RuntimeErrorType::TypeMismatch,
                                format!("unsupported operand type for -: {}", other.type_name()),
                            ));
                        }
                    };
                    self.push(result, offset)?;
                    self.ip += 1;
                }
                Opcode::Bang => {
                    let operand = self.pop(offset)?;
                    self.push(Object::Boolean(!operand.as_ref().is_truthy()).rc(), offset)?;
                    self.ip += 1;
                }
                Opcode::Eq | Opcode::Ne | Opcode::Lt | Opcode::Gt | Opcode::Le | Opcode::Ge => {
                    self.exec_comparison(opcode, offset)?;
                    self.ip += 1;
                }
                Opcode::Jump => {
                    let target = self.read_u16_operand(offset)?;
                    self.ensure_jump_target(offset, target)?;
                    self.ip = target;
                }
                Opcode::JumpIfFalse => {
                    let target = self.read_u16_operand(offset)?;
                    self.ensure_jump_target(offset, target)?;
                    // Compiler-generated bytecode expects JumpIfFalse to peek and not consume.
                    let condition = self.peek(offset)?;
                    if !condition.as_ref().is_truthy() {
                        self.ip = target;
                    } else {
                        self.ip += 3;
                    }
                }
                Opcode::SetGlobal => {
                    let idx = self.read_u16_operand(offset)?;
                    let value = self.pop(offset)?;
                    while self.globals.len() <= idx {
                        self.globals.push(Object::Null.rc());
                    }
                    self.globals[idx] = value;
                    self.ip += 3;
                }
                Opcode::GetGlobal => {
                    let idx = self.read_u16_operand(offset)?;
                    let Some(value) = self.globals.get(idx).cloned() else {
                        return Err(self.runtime_error(
                            offset,
                            RuntimeErrorType::UnknownIdentifier,
                            format!("global slot {idx} is undefined"),
                        ));
                    };
                    self.push(value, offset)?;
                    self.ip += 3;
                }
                Opcode::ReturnValue => {
                    return self.pop(offset);
                }
                Opcode::Return => {
                    return Ok(Object::Null.rc());
                }
                Opcode::InvalidBreak => {
                    return Err(self.runtime_error(
                        offset,
                        RuntimeErrorType::InvalidControlFlow,
                        "break used outside of loop",
                    ));
                }
                Opcode::InvalidContinue => {
                    return Err(self.runtime_error(
                        offset,
                        RuntimeErrorType::InvalidControlFlow,
                        "continue used outside of loop",
                    ));
                }
                Opcode::GetLocal
                | Opcode::SetLocal
                | Opcode::GetBuiltin
                | Opcode::GetFree
                | Opcode::Closure
                | Opcode::CurrentClosure
                | Opcode::Call
                | Opcode::Array
                | Opcode::Hash
                | Opcode::Index
                | Opcode::Nop => {
                    // TODO(step-17): execute functions/closures/builtins/collections and call frames.
                    return Err(self.runtime_error(
                        offset,
                        RuntimeErrorType::UnsupportedOperation,
                        format!(
                            "opcode not implemented in step 16: {}",
                            lookup_definition(opcode).name
                        ),
                    ));
                }
            }
        }

        Ok(Object::Null.rc())
    }

    pub fn last_popped(&self) -> Option<ObjectRef> {
        self.last_popped.clone()
    }

    pub fn globals(&self) -> &[ObjectRef] {
        &self.globals
    }

    fn push(&mut self, obj: ObjectRef, ip: usize) -> Result<(), RuntimeError> {
        if self.stack.len() == usize::MAX {
            return Err(self.runtime_error(
                ip,
                RuntimeErrorType::UnsupportedOperation,
                "stack overflow",
            ));
        }
        self.stack.push(obj);
        Ok(())
    }

    fn pop(&mut self, ip: usize) -> Result<ObjectRef, RuntimeError> {
        let value = self.stack.pop().ok_or_else(|| {
            self.runtime_error(
                ip,
                RuntimeErrorType::UnsupportedOperation,
                "stack underflow",
            )
        })?;
        self.last_popped = Some(value.clone());
        Ok(value)
    }

    fn peek(&self, ip: usize) -> Result<&ObjectRef, RuntimeError> {
        self.stack.last().ok_or_else(|| {
            self.runtime_error(
                ip,
                RuntimeErrorType::UnsupportedOperation,
                "stack underflow",
            )
        })
    }

    fn read_u16_operand(&self, ip: usize) -> Result<usize, RuntimeError> {
        let hi = self.chunk.instructions.get(ip + 1).ok_or_else(|| {
            self.runtime_error(
                ip,
                RuntimeErrorType::UnsupportedOperation,
                format!("truncated instruction at offset {ip}"),
            )
        })?;
        let lo = self.chunk.instructions.get(ip + 2).ok_or_else(|| {
            self.runtime_error(
                ip,
                RuntimeErrorType::UnsupportedOperation,
                format!("truncated instruction at offset {ip}"),
            )
        })?;
        Ok(u16::from_be_bytes([*hi, *lo]) as usize)
    }

    fn ensure_jump_target(&self, ip: usize, target: usize) -> Result<(), RuntimeError> {
        if target > self.chunk.instructions.len() {
            return Err(self.runtime_error(
                ip,
                RuntimeErrorType::UnsupportedOperation,
                format!(
                    "jump target out of bounds: {target} (len {})",
                    self.chunk.instructions.len()
                ),
            ));
        }
        Ok(())
    }

    fn exec_binary_arithmetic(&mut self, op: Opcode, ip: usize) -> Result<(), RuntimeError> {
        let right = self.pop(ip)?;
        let left = self.pop(ip)?;

        let result = match (left.as_ref(), right.as_ref(), op) {
            (Object::Integer(a), Object::Integer(b), Opcode::Add) => Object::Integer(a + b).rc(),
            (Object::Integer(a), Object::Integer(b), Opcode::Sub) => Object::Integer(a - b).rc(),
            (Object::Integer(a), Object::Integer(b), Opcode::Mul) => Object::Integer(a * b).rc(),
            (Object::Integer(_), Object::Integer(0), Opcode::Div) => {
                return Err(self.runtime_error(
                    ip,
                    RuntimeErrorType::DivisionByZero,
                    "division by zero",
                ));
            }
            (Object::Integer(a), Object::Integer(b), Opcode::Div) => Object::Integer(a / b).rc(),
            (Object::String(a), Object::String(b), Opcode::Add) => {
                Object::String(format!("{a}{b}")).rc()
            }
            (Object::String(_), Object::String(_), _) => {
                return Err(self.runtime_error(
                    ip,
                    RuntimeErrorType::UnsupportedOperation,
                    format!(
                        "unsupported string operation: {}",
                        lookup_definition(op).name
                    ),
                ));
            }
            (l, r, _) => {
                return Err(self.runtime_error(
                    ip,
                    RuntimeErrorType::TypeMismatch,
                    format!(
                        "unsupported operand types for {}: {} and {}",
                        lookup_definition(op).name,
                        l.type_name(),
                        r.type_name()
                    ),
                ));
            }
        };

        self.push(result, ip)
    }

    fn exec_comparison(&mut self, op: Opcode, ip: usize) -> Result<(), RuntimeError> {
        let right = self.pop(ip)?;
        let left = self.pop(ip)?;

        let value = match (left.as_ref(), right.as_ref()) {
            (Object::Integer(a), Object::Integer(b)) => match op {
                Opcode::Eq => a == b,
                Opcode::Ne => a != b,
                Opcode::Lt => a < b,
                Opcode::Gt => a > b,
                Opcode::Le => a <= b,
                Opcode::Ge => a >= b,
                _ => unreachable!("comparison opcode already filtered"),
            },
            (Object::Boolean(a), Object::Boolean(b)) => match op {
                Opcode::Eq => a == b,
                Opcode::Ne => a != b,
                _ => {
                    return Err(self.runtime_error(
                        ip,
                        RuntimeErrorType::TypeMismatch,
                        format!(
                            "unsupported operand types for {}: BOOLEAN and BOOLEAN",
                            lookup_definition(op).name
                        ),
                    ));
                }
            },
            (Object::Null, Object::Null) => match op {
                Opcode::Eq => true,
                Opcode::Ne => false,
                _ => {
                    return Err(self.runtime_error(
                        ip,
                        RuntimeErrorType::TypeMismatch,
                        format!(
                            "unsupported operand types for {}: NULL and NULL",
                            lookup_definition(op).name
                        ),
                    ));
                }
            },
            (Object::String(a), Object::String(b)) => match op {
                Opcode::Eq => a == b,
                Opcode::Ne => a != b,
                Opcode::Lt | Opcode::Gt | Opcode::Le | Opcode::Ge => {
                    return Err(self.runtime_error(
                        ip,
                        RuntimeErrorType::UnsupportedOperation,
                        format!(
                            "unsupported string operation: {}",
                            lookup_definition(op).name
                        ),
                    ));
                }
                _ => unreachable!("comparison opcode already filtered"),
            },
            (l, r) => {
                return Err(self.runtime_error(
                    ip,
                    RuntimeErrorType::TypeMismatch,
                    format!(
                        "unsupported operand types for {}: {} and {}",
                        lookup_definition(op).name,
                        l.type_name(),
                        r.type_name()
                    ),
                ));
            }
        };

        self.push(Object::Boolean(value).rc(), ip)
    }

    fn runtime_error(
        &self,
        ip: usize,
        error_type: RuntimeErrorType,
        message: impl Into<String>,
    ) -> RuntimeError {
        let pos = self.chunk.position_for_offset(ip).unwrap_or_default();
        RuntimeError::new(error_type, message, pos)
    }
}
